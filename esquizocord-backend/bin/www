#!/usr/bin/env node

/**
 * Módulos necessários.
 */
const { app, sessionMiddleware } = require("../app");
const debug = require("debug")("esquizocord-backend:server");
const http = require("http");
const { Server } = require("socket.io");

/**
 * Obtém a porta do ambiente e guarda no Express.
 */
const port = normalizePort(process.env.PORT || "3000");
app.set("port", port);

/**
 * Cria o servidor HTTP.
 */
const server = http.createServer(app);
/**
 * Inicializa o Socket.IO com a configuração de CORS explícita.
 */
const io = new Server(server, {
  cors: {
    origin: process.env.FRONTEND_URL || "http://localhost:5173",
    methods: ["GET", "POST"],
    credentials: true,
  },
  // --- ADIÇÃO AQUI ---
  // Mantém a conexão viva em ambientes de hospedagem como o Render
  pingTimeout: 60000,
  pingInterval: 25000,
});
// Envolve o middleware de sessão para ser compatível com o Socket.IO
const wrap = (middleware) => (socket, next) =>
  middleware(socket.request, {}, next);
io.use(wrap(sessionMiddleware));

const voiceChannels = {};

// Lógica de gestão de conexões do Socket.IO
io.on("connection", (socket) => {
  console.log("Um cliente conectou-se via WebSocket:", socket.id);

  const session = socket.request.session;
  if (!session || !session.user) {
    console.log(`Socket ${socket.id} não autenticado. Desconectando.`);
    return socket.disconnect(true);
  }

  // --- ALTERAÇÃO 1: Armazene o ID do usuário diretamente no socket ---
  // Isso torna o socket independente da sessão após a conexão inicial.
  socket.userId = session.user.id_usuario;

  const currentUserInfo = {
    id_usuario: socket.userId,
    socketId: socket.id,
    nome: session.user.nome,
    foto_perfil: session.user.foto_perfil,
  };
  console.log(
    `Socket ${socket.id} autenticado como utilizador ${socket.userId}`
  );

  const onlineUsers = app.get("onlineUsers") || new Set();
  onlineUsers.add(socket.userId);
  app.set("onlineUsers", onlineUsers);
  io.emit("user_online", { userId: socket.userId });

  socket.on("join_dm_room", (roomName) => socket.join(roomName));
  socket.on("leave_dm_room", (roomName) => socket.leave(roomName));
  socket.on("join_group_room", (roomName) => socket.join(roomName));
  socket.on("leave_group_room", (roomName) => socket.leave(roomName));

  // --- LÓGICA DE CANAL DE VOZ (sem alterações aqui) ---
  socket.on("join-voice-channel", (channelId) => {
    socket.join(`voice-${channelId}`);
    if (!voiceChannels[channelId]) {
      voiceChannels[channelId] = {};
    }
    const usersInChannel = Object.values(voiceChannels[channelId]);
    socket.emit("all-users-in-voice-channel", usersInChannel);
    voiceChannels[channelId][socket.id] = currentUserInfo;
    socket.to(`voice-${channelId}`).emit("user-joined-voice", currentUserInfo);
  });

  socket.on("webrtc-offer", ({ targetSocketId, offer }) => {
    socket
      .to(targetSocketId)
      .emit("webrtc-offer", { fromSocketId: socket.id, offer });
  });

  socket.on("webrtc-answer", ({ targetSocketId, answer }) => {
    socket
      .to(targetSocketId)
      .emit("webrtc-answer", { fromSocketId: socket.id, answer });
  });

  socket.on("webrtc-ice-candidate", ({ targetSocketId, candidate }) => {
    socket
      .to(targetSocketId)
      .emit("webrtc-ice-candidate", { fromSocketId: socket.id, candidate });
  });

  const handleLeaveVoice = () => {
    for (const channelId in voiceChannels) {
      if (voiceChannels[channelId][socket.id]) {
        socket.leave(`voice-${channelId}`);
        delete voiceChannels[channelId][socket.id];
        io.to(`voice-${channelId}`).emit("user-left-voice", {
          socketId: socket.id,
        });
      }
    }
  };

  socket.on("leave-voice-channel", handleLeaveVoice);
  // --- FIM DA LÓGICA DE CANAL DE VOZ ---

  socket.on("disconnect", () => {
    // --- ALTERAÇÃO 2: Use o ID do socket em vez da variável de sessão ---
    // Agora a limpeza é 100% confiável, mesmo se a sessão foi destruída.
    if (socket.userId) {
      onlineUsers.delete(socket.userId);
      app.set("onlineUsers", onlineUsers);
      io.emit("user_offline", { userId: socket.userId });
      handleLeaveVoice(); // Reutiliza a lógica de saída ao desconectar
      console.log(
        `Cliente ${socket.id} (Utilizador ${socket.userId}) desconectou-se.`
      );
    } else {
      console.log(`Cliente ${socket.id} (não autenticado) desconectou-se.`);
    }
  });
});

// Disponibiliza o 'io' para todas as rotas da app
app.set("io", io);
/**
 * O servidor começa a escutar na porta especificada.
 */
server.listen(port);
server.on("error", onError);
server.on("listening", onListening);
/**
 * Normaliza a porta para um número, string ou false.
 */
function normalizePort(val) {
  const port = parseInt(val, 10);
  if (isNaN(port)) {
    // named pipe
    return val;
  }
  if (port >= 0) {
    // port number
    return port;
  }
  return false;
}

/**
 * Event listener para o evento "error" do servidor HTTP.
 */
function onError(error) {
  if (error.syscall !== "listen") {
    throw error;
  }
  const bind = typeof port === "string" ? "Pipe " + port : "Port " + port;
  switch (error.code) {
    case "EACCES":
      console.error(bind + " requer privilégios elevados");
      process.exit(1);
      break;
    case "EADDRINUSE":
      console.error(bind + " já está em uso");
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener para o evento "listening" do servidor HTTP.
 */
function onListening() {
  const addr = server.address();
  const bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
  debug("A escutar em " + bind);
  console.log("Servidor a correr em http://localhost:" + port);
}
